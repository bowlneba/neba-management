@using Neba.Web.Server.Services
@using System.Reactive.Linq
@implements IDisposable
@implements IAsyncDisposable
@inject INotificationService NotificationService
@inject IJSRuntime JS
@rendermode InteractiveServer

@if (_currentToast is not null)
{
    <div class="neba-toast-container">
        <NebaToast Payload="@_currentToast.Payload"
                  Duration="@_effectiveDuration"
                  PauseOnHover="@PauseOnHover"
                  OnDismiss="@HandleToastDismissed"
                  @key="_currentToast.Id" />
    </div>
}

@code {
    private readonly Queue<ToastItem> _toastQueue = new();
    private ToastItem? _currentToast;
    private IDisposable? _subscription;
    private IJSObjectReference? _module;
    private bool _isMobile;
    private TimeSpan _effectiveDuration = TimeSpan.FromMilliseconds(ToastDefaults.DesktopDurationMs);

    /// <summary>
    /// Whether to pause auto-dismiss timer when hovering over toasts.
    /// </summary>
    [Parameter]
    public bool PauseOnHover { get; set; } = true;

    protected override void OnInitialized()
    {
        // Subscribe to NotificationService and filter for toast-targeted notifications
        _subscription = NotificationService.Notifications
            .Where(payload => payload.Behavior is NotifyBehavior.ToastOnly or NotifyBehavior.AlertAndToast)
            .Subscribe(payload =>
            {
                InvokeAsync(() =>
                {
                    AddToast(payload);
                    StateHasChanged();
                });
            });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _module = await JS.InvokeAsync<IJSObjectReference>("import", "./Components/Notifications/ToastManager.razor.js");
            _isMobile = await _module.InvokeAsync<bool>("isMobile");
            _effectiveDuration = _isMobile
                ? TimeSpan.FromMilliseconds(ToastDefaults.MobileDurationMs)
                : TimeSpan.FromMilliseconds(ToastDefaults.DesktopDurationMs);
            StateHasChanged();
        }
    }

    private void AddToast(NotificationPayload payload)
    {
        var toastItem = new ToastItem
        {
            Id = Guid.NewGuid(),
            Payload = payload
        };

        // If no toast is currently displayed, show this one immediately
        if (_currentToast is null)
        {
            _currentToast = toastItem;
        }
        else
        {
            // Enforce max queue size to prevent unbounded growth
            if (_toastQueue.Count >= ToastDefaults.MaxQueueSize)
            {
                // Drop the oldest toast to make room for the new one
                _toastQueue.Dequeue();
            }

            // Queue the new toast
            _toastQueue.Enqueue(toastItem);
        }
    }

    private void HandleToastDismissed()
    {
        // Clear current toast
        _currentToast = null;

        // Show next toast in queue if available
        if (_toastQueue.Count > 0)
        {
            _currentToast = _toastQueue.Dequeue();
        }

        StateHasChanged();
    }

    private bool _disposed;

    public void Dispose()
    {
        Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }

    public async ValueTask DisposeAsync()
    {
        await DisposeAsyncCore();
        Dispose(disposing: false);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                _subscription?.Dispose();
            }
            _disposed = true;
        }
    }

    protected virtual async ValueTask DisposeAsyncCore()
    {
        if (_module is not null)
        {
            try
            {
                await _module.DisposeAsync();
            }
            catch (Microsoft.JSInterop.JSDisconnectedException)
            {
                // Circuit is already disconnected, safe to ignore
            }
        }
        _subscription?.Dispose();
    }
}
